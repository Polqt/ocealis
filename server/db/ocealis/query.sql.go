// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package ocealis

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBottle = `-- name: CreateBottle :one
INSERT INTO bottles (sender_id, message_text, bottle_style, start_lat, start_lng, scheduled_release)
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, sender_id, message_text, bottle_style, start_lat, start_lng, hops, scheduled_release, is_release, created_at
`

type CreateBottleParams struct {
	SenderID         pgtype.Int4
	MessageText      string
	BottleStyle      pgtype.Int4
	StartLat         pgtype.Float8
	StartLng         pgtype.Float8
	ScheduledRelease pgtype.Timestamptz
}

func (q *Queries) CreateBottle(ctx context.Context, arg CreateBottleParams) (Bottle, error) {
	row := q.db.QueryRow(ctx, createBottle,
		arg.SenderID,
		arg.MessageText,
		arg.BottleStyle,
		arg.StartLat,
		arg.StartLng,
		arg.ScheduledRelease,
	)
	var i Bottle
	err := row.Scan(
		&i.ID,
		&i.SenderID,
		&i.MessageText,
		&i.BottleStyle,
		&i.StartLat,
		&i.StartLng,
		&i.Hops,
		&i.ScheduledRelease,
		&i.IsRelease,
		&i.CreatedAt,
	)
	return i, err
}

const createBottleEvent = `-- name: CreateBottleEvent :one
INSERT INTO bottle_events (bottle_id, event_type, lat, lng)
VALUES ($1, $2, $3, $4) RETURNING id, bottle_id, event_type, lat, lng, created_at
`

type CreateBottleEventParams struct {
	BottleID  pgtype.Int4
	EventType string
	Lat       pgtype.Float8
	Lng       pgtype.Float8
}

func (q *Queries) CreateBottleEvent(ctx context.Context, arg CreateBottleEventParams) (BottleEvent, error) {
	row := q.db.QueryRow(ctx, createBottleEvent,
		arg.BottleID,
		arg.EventType,
		arg.Lat,
		arg.Lng,
	)
	var i BottleEvent
	err := row.Scan(
		&i.ID,
		&i.BottleID,
		&i.EventType,
		&i.Lat,
		&i.Lng,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (nickname, avatar_url) VALUES ($1, $2) RETURNING id, nickname, avatar_url, created_at
`

type CreateUserParams struct {
	Nickname  string
	AvatarUrl pgtype.Text
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Nickname, arg.AvatarUrl)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Nickname,
		&i.AvatarUrl,
		&i.CreatedAt,
	)
	return i, err
}

const getBottle = `-- name: GetBottle :one
SELECT id, sender_id, message_text, bottle_style, start_lat, start_lng, hops, scheduled_release, is_release, created_at FROM bottles WHERE id = $1
`

func (q *Queries) GetBottle(ctx context.Context, id int32) (Bottle, error) {
	row := q.db.QueryRow(ctx, getBottle, id)
	var i Bottle
	err := row.Scan(
		&i.ID,
		&i.SenderID,
		&i.MessageText,
		&i.BottleStyle,
		&i.StartLat,
		&i.StartLng,
		&i.Hops,
		&i.ScheduledRelease,
		&i.IsRelease,
		&i.CreatedAt,
	)
	return i, err
}

const getBottleEvents = `-- name: GetBottleEvents :many
SELECT id, bottle_id, event_type, lat, lng, created_at FROM bottle_events WHERE bottle_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetBottleEvents(ctx context.Context, bottleID pgtype.Int4) ([]BottleEvent, error) {
	rows, err := q.db.Query(ctx, getBottleEvents, bottleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BottleEvent
	for rows.Next() {
		var i BottleEvent
		if err := rows.Scan(
			&i.ID,
			&i.BottleID,
			&i.EventType,
			&i.Lat,
			&i.Lng,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT id, nickname, avatar_url, created_at FROM users WHERE id = $1
`

func (q *Queries) GetUser(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Nickname,
		&i.AvatarUrl,
		&i.CreatedAt,
	)
	return i, err
}
